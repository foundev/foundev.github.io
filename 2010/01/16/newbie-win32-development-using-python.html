---
wordpress_id: 36
title: Newbie Win32 Development Using Python
date: 2010-01-16T04:35:33+00:00
author: Ryan Svihla
layout: post
wordpress_guid: /blogs/rssvihla/archive/2010/01/15/newbie-win32-development-using-python.aspx
dsq_thread_id:
  - "1075599217"
categories:
  - DotNet
  - Python
redirect_from: "/blogs/rssvihla/archive/2010/01/15/newbie-win32-development-using-python.aspx/"
---
<p>First a disclaimer. I’m not in anyway shape or form an experienced win32 systems programmer.&#160; I’ve always done application development or systems administration scripting. That in-between area where you get out your C/C++ compiler and start dealing with pointers is completely alien to me.&#160; This has created problems in the past when I need to do something outside of the scope of C# and found myself staring at MSDN docs in C trying to extrapolate the equivalent C# code, and typically being disgusted at having to use hand rolled Structs with calls to Marshall.GetLastWin32Error().</p>
<p>Worse still I end up with a nasty implementation that requires slow, fragile integration tests to verify behavior or very verbose mirror interfaces where I’m testing order of calls. Look at the following code sample to read a reparse point’s target directory from <a href="http://www.codeproject.com/KB/vista/Windows_Vista.aspx" target="_blank">code project</a>:</p>
<div style="padding-bottom: 0px;margin: 0px;padding-left: 0px;padding-right: 0px;float: none;padding-top: 0px" class="wlWriterEditableSmartContent">
  <div style="font-family:consolas,lucida console,courier,monospace">
    &#160;<span style="color:#008000">//&#160;Allocate&#160;a&#160;buffer&#160;for&#160;the&#160;reparse&#160;point&#160;data:<br /> </span>Int32&#160;outBufferSize&#160;=&#160;Marshal.SizeOf(<span style="color:#0000ff">typeof</span>(REPARSE_GUID_DATA_BUFFER));<br /> IntPtr&#160;outBuffer&#160;=&#160;Marshal.AllocHGlobal(outBufferSize);<br /> &#160;<br /> <span style="color:#0000ff">try</span><br /> <span style="color:#0000ff">{</span><br /> &#160;<span style="color:#008000">//&#160;Read&#160;the&#160;reparse&#160;point&#160;data:<br /> </span>Int32&#160;bytesReturned;<br /> <span style="color:#008000">//&#160;WOW&#160;what&#160;a&#160;signature,&#160;it&#8217;s&#160;requiring&#160;blank&#160;data!&#160;<br /> //&#160;Looking&#160;at&#160;MSDN&#160;the&#160;signaure&#160;contains&#160;input&#160;and&#160;output&#160;buffer&#160;and&#160;size<br /> //&#160;for&#160;both,&#160;meaning&#160;I&#8217;m&#160;always&#160;sending&#160;something&#160;as&#160;IntPtr.Zero<br /> </span>Int32&#160;readOK&#160;=&#160;DeviceIoControl(&#160;hFile,FSCTL_GET_REPARSE_POINT,&#160;IntPtr.Zero,&#160;0,<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;outBuffer,&#160;outBufferSize,&#160;<span style="color:#0000ff">out</span>&#160;bytesReturned,IntPtr.Zero);<br /> <span style="color:#0000ff">if</span>&#160;(readOK&#160;!=&#160;0)<br /> &#160;&#160;&#160;<span style="color:#0000ff">{</span><br /> &#160;&#160;&#160;<span style="color:#008000">//&#160;Get&#160;the&#160;target&#160;directory&#160;from&#160;the&#160;reparse&#160;<br /> </span>&#160;&#160;&#160;<span style="color:#008000">//&#160;point&#160;data:<br /> </span>&#160;&#160;&#160;REPARSE_GUID_DATA_BUFFER&#160;rgdBuffer&#160;=<br /> &#160;&#160;&#160;(REPARSE_GUID_DATA_BUFFER)Marshal.PtrToStructure(outBuffer,&#160;<span style="color:#0000ff">typeof</span>(REPARSE_GUID_DATA_BUFFER));<br /> &#160;&#160;&#160;targetDir&#160;=&#160;Encoding.Unicode.GetString(&#160;rgdBuffer.PathBuffer,rgdBuffer.SubstituteNameOffset,<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rgdBuffer.SubstituteNameLength);<br /> &#160;&#160;</p> 

    <p>
      <span style="color:#008000">//removed&#160;a&#160;bunch&#160;more&#160;stuff&#160;to&#160;format&#160;the&#160;result<br /> </span>&#160;<br /> <span style="color:#008000">//&#160;Free&#160;the&#160;buffer&#160;for&#160;the&#160;reparse&#160;point&#160;data:<br /> </span>&#160;Marshal.FreeHGlobal(outBuffer);<br /> &#160;<br /> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </div> </div>

<pre><code>  &lt;p&gt;
    &amp;#160;
  &lt;/p&gt;

  &lt;p&gt;
    In the past when building these kind of things for less complicated code I just would mirror out all the untestable code like Marshal , DeviceIoControl and CloseHandle calls with interfaces, then create a production wrapper.&amp;#160; This however leads to very long tests, with lots of specifics about the internals of the interaction, in the above example the support code looks like:
  &lt;/p&gt;

  &lt;div style="padding-bottom: 0px;margin: 0px;padding-left: 0px;padding-right: 0px;float: none;padding-top: 0px" class="wlWriterEditableSmartContent"&gt;
    &lt;div style="font-family:consolas,lucida console,courier,monospace"&gt;
      &amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;span style="color:#0000ff"&gt;public&lt;/span&gt;&amp;#160;&lt;span style="color:#0000ff"&gt;interface&lt;/span&gt;&amp;#160;IMarshal&lt;br /&gt; &amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;span style="color:#0000ff"&gt;{&lt;/span&gt;&lt;/p&gt;

      &lt;p&gt;
        &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;span style="color:#0000ff"&gt;void&lt;/span&gt;&amp;#160;FreeHGlobal(IntPtr&amp;#160;buffer);&lt;br /&gt; &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;Object&amp;#160;PtrToStructure(IntPtr&amp;#160;pointer,&amp;#160;Type&amp;#160;structure);&lt;br /&gt; &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;Int32&amp;#160;SizeOf(Type&amp;#160;structure);&lt;br /&gt; &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;IntPtr&amp;#160;AllocHGlobal(&lt;span style="color:#2b91af"&gt;int&lt;/span&gt;&amp;#160;cb);&lt;br /&gt; &amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;span style="color:#0000ff"&gt;}&lt;/span&gt;
      &lt;/p&gt;

      &lt;p&gt;
        &amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;span style="color:#0000ff"&gt;public&lt;/span&gt;&amp;#160;&lt;span style="color:#0000ff"&gt;class&lt;/span&gt;&amp;#160;&lt;span style="color:#2b91af"&gt;ProdMarshal&lt;/span&gt;&amp;#160;:&amp;#160;IMarshal&lt;br /&gt; &amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;span style="color:#0000ff"&gt;{&lt;/span&gt;&lt;br /&gt; &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;span style="color:#0000ff"&gt;public&lt;/span&gt;&amp;#160;&lt;span style="color:#0000ff"&gt;void&lt;/span&gt;&amp;#160;FreeHGlobal(IntPtr&amp;#160;buffer)&lt;span style="color:#0000ff"&gt;{&lt;/span&gt;&lt;br /&gt; &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;br /&gt; &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;Marshal.FreeHGlobal(buffer);&lt;br /&gt; &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;span style="color:#0000ff"&gt;}&lt;/span&gt;
      &lt;/p&gt;

      &lt;p&gt;
        &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;span style="color:#008000"&gt;//&amp;#160;you&amp;#160;get&amp;#160;the&amp;#160;idea&amp;#160;from&amp;#160;here&amp;#160;&lt;br /&gt; &lt;/span&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;span style="color:#0000ff"&gt;}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;

        &lt;p&gt;
          Not terribly pretty mocking and testing this leads to is it?&amp;#160; This isn’t also counting the win32 calls that are needed to setup and finalize the data around this. Before its all said and done to make this “testable” you end up with 2 interfaces, 2 wrapper production classes, and very heavy interaction specific mocking to even handle this basic idea of getting a value from a file system object.&amp;#160; Before you try and point out “well you can reuse that logic later” look at the size of Marshal and ask yourself do you really want to mock all that out?
        &lt;/p&gt;

        &lt;p&gt;
          Adding insult to injury your mocks have to be very good to replicate the behavior of the actual real thing, and it varies greatly across platforms. Windows 7 and server 2008 r2 allow reparse points (or symlinks in the this case) from directory to directory, but Vista and 2008 r1 are a no go and will fail.
        &lt;/p&gt;

        &lt;p&gt;
          No wonder the systems developers that I know completely turn there nose up at unit testing and instead focus on slow integration or systems tests. The abstractions take time to make happen and the code itself is just not testable without lots of mirrored interfaces.
        &lt;/p&gt;

        &lt;p&gt;
          So not wanting to spend all my time just writing mirrored interfaces day in and out for win32 calls, nor liking the idea of turning my back on unit testing, I decided to take a look at dynamic languages win32 support.
        &lt;/p&gt;

        &lt;p&gt;
          First I looked at Ruby and the win32 libraries I saw didn’t give me the above functionality I needed with the minimal amount of hassle I wanted. DeviceIoControl up there for example with its stunningly bad signature is still pretty rough in Ruby as they have a one to one signature mapping.&amp;#160;
        &lt;/p&gt;

        &lt;p&gt;
          Python however has had for a very long time strong win32api support and removes some of the awful pain that you have to deal with. Below is the equivalent of the code above, again with items stripped out for brevity before and after it, but they’re roughly computationally equivalent and the Python version wins out more the more I include.
        &lt;/p&gt;

        &lt;p&gt;
          &amp;#160;
        &lt;/p&gt;

        &lt;div style="padding-bottom: 0px;margin: 0px;padding-left: 0px;padding-right: 0px;float: none;padding-top: 0px" class="wlWriterEditableSmartContent"&gt;
          &lt;div style="font-family:consolas,lucida console,courier,monospace"&gt;
            &lt;span style="color:#000000"&gt;output_buf&lt;/span&gt;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;=&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;win32file&lt;/span&gt;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;.&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;AllocateReadBuffer&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;(&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;winnt&lt;/span&gt;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;.&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;MAXIMUM_REPARSE_DATA_BUFFER_SIZE&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;)&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;br /&gt; &lt;span style="color:#8f5902"&gt;&lt;i&gt;#notice&amp;#160;how&amp;#160;I&amp;#160;don&amp;#8217;t&amp;#160;have&amp;#160;to&amp;#160;pass&amp;#160;in&amp;#160;size&amp;#160;of&amp;#160;the&amp;#160;buffers&amp;#160;now.&amp;#160;I&amp;#160;still&amp;#160;have&amp;#160;the&amp;#160;need&amp;#160;to&amp;#160;&lt;/i&gt;&lt;/span&gt;&lt;br /&gt; &lt;span style="color:#8f5902"&gt;&lt;i&gt;#&amp;#160;pass&amp;#160;None&amp;#160;in&amp;#160;for&amp;#160;the&amp;#160;input&amp;#160;buffer&amp;#160;here&amp;#160;however&lt;/i&gt;&lt;/span&gt;&lt;br /&gt; &lt;span style="color:#000000"&gt;buf&lt;/span&gt;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;=&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;win32file&lt;/span&gt;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;.&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;DeviceIoControl&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;(&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;h&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;,&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;span style="color:#000000"&gt;winioctlcon&lt;/span&gt;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;.&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;FSCTL_GET_REPARSE_POINT&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;,&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#3465a4"&gt;None&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;,&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;OutBuffer&lt;/span&gt;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;=&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;output_buf&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;,&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;span style="color:#000000"&gt;Overlapped&lt;/span&gt;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;=&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#3465a4"&gt;None&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;)&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;br /&gt; &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;br /&gt; &lt;span style="color:#000000"&gt;fixed_fmt&lt;/span&gt;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;=&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#4e9a06"&gt;&amp;#8216;LHHHHHH&amp;#8217;&lt;/span&gt;&amp;#160;&lt;br /&gt; &lt;span style="color:#000000"&gt;fixed_len&lt;/span&gt;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;=&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;struct&lt;/span&gt;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;.&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;calcsize&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;(&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;fixed_fmt&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;)&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;br /&gt; &lt;span style="color:#000000"&gt;tag&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;,&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;span style="color:#000000"&gt;datalen&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;,&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;span style="color:#000000"&gt;reserved&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;,&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;span style="color:#000000"&gt;target_offset&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;,&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;span style="color:#000000"&gt;target_len&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;,&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;span style="color:#000000"&gt;printname_offset&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;,&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;span style="color:#000000"&gt;printname_len&lt;/span&gt;&amp;#160;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;=&lt;/b&gt;&lt;/span&gt;&amp;#160;&amp;#160;&lt;br /&gt; &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&lt;span style="color:#000000"&gt;struct&lt;/span&gt;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;.&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;unpack&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;(&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;fixed_fmt&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;,&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;span style="color:#000000"&gt;buf&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;[:&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;fixed_len&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;])&lt;/b&gt;&lt;/span&gt;&amp;#160;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;p&gt;
          &amp;#160;
        &lt;/p&gt;

        &lt;p&gt;
          It’s still not pretty, but its briefer, and I can actually stub out or test struct.calcsize, AllocateReadBuffer and DeviceIoControl with no need to mess around with setting up lots of test harness code. Using my current mocking framework the test code looks something like this:
        &lt;/p&gt;

        &lt;p&gt;
          &amp;#160;
        &lt;/p&gt;

        &lt;div style="padding-bottom: 0px;margin: 0px;padding-left: 0px;padding-right: 0px;float: none;padding-top: 0px" class="wlWriterEditableSmartContent"&gt;
          &lt;div style="font-family:consolas,lucida console,courier,monospace"&gt;
            &lt;span style="color:#000000"&gt;alloc&lt;/span&gt;&amp;#160;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;=&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;span style="color:#000000"&gt;mock&lt;/span&gt;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;.&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;replaceWithMock&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;(&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;win32file&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;,&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;span style="color:#4e9a06"&gt;&amp;#8220;AllocateReadBuffer&amp;#8221;&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;)&lt;/b&gt;&lt;/span&gt;&lt;br /&gt; &lt;span style="color:#204a87"&gt;buffer&lt;/span&gt;&amp;#160;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;=&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;span style="color:#204a87"&gt;object&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;()&lt;/b&gt;&lt;/span&gt;&lt;br /&gt; &lt;span style="color:#000000"&gt;alloc&lt;/span&gt;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;.&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;stub&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;(&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#204a87"&gt;buffer&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;)&lt;/b&gt;&lt;/span&gt;&lt;/p&gt;

            &lt;p&gt;
              &lt;span style="color:#8f5902"&gt;&lt;i&gt;#removed&amp;#160;extra&amp;#160;setup&amp;#160;code&amp;#160;for&amp;#160;calcsize&amp;#160;and&amp;#160;DeviceIoControl&lt;/i&gt;&lt;/span&gt;
            &lt;/p&gt;

            &lt;p&gt;
              &lt;span style="color:#000000"&gt;getTargetDir&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;()&lt;/b&gt;&lt;/span&gt;
            &lt;/p&gt;

            &lt;p&gt;
              &lt;span style="color:#000000"&gt;mock&lt;/span&gt;&lt;span style="color:#ce5c00"&gt;&lt;b&gt;.&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;assertCalled&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;(&lt;/b&gt;&lt;/span&gt;&lt;span style="color:#000000"&gt;win32file&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;,&lt;/b&gt;&lt;/span&gt;&amp;#160;&lt;span style="color:#4e9a06"&gt;&amp;#8220;AllocateReadBuffer&amp;#8221;&lt;/span&gt;&lt;span style="color:#000000"&gt;&lt;b&gt;)&lt;/b&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;

              &lt;p&gt;
                &amp;#160;
              &lt;/p&gt;

              &lt;p&gt;
                Much cleaner, much lower friction and so I’m satisfied with Python for win32 development so far.&amp;#160; I’ll give C# another look when I have the dynamic keyword and I don’t have to make explicit mirror interfaces for everything that’s untestable.
              &lt;/p&gt;
</code></pre>