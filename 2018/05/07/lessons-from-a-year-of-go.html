<hr />
<p>title: 'Lessons from a year of Golang'
date: 2018-05-07T13:16:00+00:00
author: Ryan Svihla
layout: post
tags: [</p>
<hr />
<p>I’m hoping to share in a non-negative way help others avoid the pitfalls I ran into with my most recent work building infrastructure software on top of a Kubernetes using Go, it sounded like an awesome job at first but I ran into a lot of problems getting productive. </p>
<p>This isn’t meant to evaluate if you should pick up Go or tell you what you should think of it, this is strictly meant to help people out that are new to the language but experienced in Java, Python, Ruby, C#, etc and have read some basic Go getting started guide.</p>
<h2>Dependency management</h2>
<p>This is probably the feature most frequently talked about by newcomers to Go and with some justification, as dependency management in Go has been a rapidly shifting area that’s nothing like what experienced Java, C#, Ruby or Python developers are used to. </p>
<p>Today, the default tool is <a href="https://github.com/golang/dep">Dep</a> all other tools I’ve used such as <a href="https://github.com/Masterminds/glide">Glide</a> or <a href="https://github.com/tools/godep">Godep</a> are  deprecated in favor of Dep, and while Dep has advanced rapidly there are some problems you’ll eventually run into (or I did):</p>
<ol>
<li>Dep hangs randomly and is slow, which is supposedly network traffic <a href="https://github.com/golang/dep/blob/c8be449181dadcb01c9118a7c7b592693c82776f/docs/failure-modes.md#hangs">but it happens to everyone I know with tons of bandwidth</a>. Regardless, I’d like an option to supply a timeout and report an error.</li>
<li>Versions and transitive depency conflicts can be a real breaking issue in Go. So without shading or it’s equivalent two package depending on different versions of a given package can break your build, there are a number or proposals to fix this but we’re not there yet.</li>
<li>Dep has some goofy ways it resolves transitive dependencies and you may have to add explicit references to them in your Gopkg.toml file. You can see an example <a href="https://kubernetes.io/blog/2018/01/introducing-client-go-version-6/">here</a> under <strong>Updating dependencies – golang/dep</strong>.</li>
</ol>
<h3>My advice</h3>
<ul>
<li>Avoid hangs by checking in your dependencies directly into your source repository and just using the dependency tool (dep, godep, glide it doesn’t matter) for downloading dependencies.</li>
<li>Minimize transitive dependencies by keeping stuff small and using patterns like microservices when your dependency tree conflicts.</li>
</ul>
<h2>GOPATH</h2>
<p>Something that takes some adjustment is you check out all your source code in one directory with one path (by default \~/go/src ) and include the path to the source tree to where you check out. Example:</p>
<ol>
<li>I want to use a package I found on github called jim/awesomeness </li>
<li>I have to go to \~/go/src and mkdir -p github.com/jim</li>
<li>cd into that and clone the package.</li>
<li>When I reference the package in my source file it’ll be literally importing github.com/jim/awesomeness</li>
</ol>
<p>A better guide to GOPATH and packages is <a href="https://thenewstack.io/understanding-golang-packages/">here</a>.</p>
<h3>My advice</h3>
<p>Don’t fight it, it’s actually not so bad once you embrace it.</p>
<h2>Code structure</h2>
<p>This is a hot topic and there are a few standards for the right way to structure you code from projects that do “file per class” to giant files with general concept names (think like types.go and net.go). Also if you’re used to using a lot of sub package you’re gonna to have issues with not being able to compile if for example you have two sub packages reference one another. </p>
<h3>My Advice</h3>
<p>In the end I was reasonably ok with something like the following:</p>
<ul>
<li>myproject/bin for generated executables</li>
<li>myproject/cmd for command line code</li>
<li>myproject/pkg for code related to the package</li>
</ul>
<p>Now whatever you do is fine, this was just a common idiom I saw, but it wasn’t remotely all projects. I also had some luck with just jamming everything into the top level of the package and keeping packages small (and making new packages for common code that is used in several places in the code base). If I ever return to using Go for any reason I will probably just jam everything into the top level directory.</p>
<h2>Debugging</h2>
<p>No debugger! There are some projects attempting to add one but Rob Pike finds them a crutch.</p>
<h3>My Advice</h3>
<p>Lots of unit tests and print statements. </p>
<h2>No generics</h2>
<p>Sorta self explanatory and it causes you a lot of pain when you’re used to reaching for these.</p>
<h3>My advice</h3>
<p>Look at the code generation support which uses pragmas, this is not exactly the same as having generics but if you have some code that has a lot of boiler plate without them this is a valid alternative.  See this official <a href="https://blog.golang.org/generate">Go Blog post</a> for more details.</p>
<p>If you don’t want to use generation you really only have reflection left as a valid tool, which comes with all of it’s lack of speed and type safety.</p>
<h2>Cross compiling</h2>
<p>If you have certain features or dependencies you may find you cannot take advantage of one of Go’s better features cross compilation.</p>
<p>I ran into this when using the confluent-go/kafka library which depends on the C librdkafka library. It basically meant I had to do all my development in a Linux VM because almost all our packages relied on this. </p>
<h3>My Advice</h3>
<p>Avoid C dependencies at all costs.</p>
<h2>Error handling</h2>
<p>Go error handling is not exception base but return based, and it’s got a lot of common idioms around it:</p>
<pre><code>myValue, err := doThing()
if err != nil {
    return -1, fmt.Errorf(“unable to doThing %v”, err)
}
</code></pre>
<p>Needless to say this can get very wordy when dealing with deeply nested exceptions or when you’re interacting a lot with external systems.  It is definitely a mind shift if you’re used to the throwing exceptions wherever and have one single place to catch all exceptions where they’re handled appropriately.</p>
<h3>My Advice</h3>
<p>I’ll be honest I never totally made my peace with this. I had good training from experienced opensource contributors to major Go projects, read all the right blog posts, definitely felt like I’d heard enough from the community on why the current state of Go error handling was great in their opinions, but the lack of stack traces was a deal breaker for me.  </p>
<p>On the positive side, I found Dave Cheney’s advice on error handling to be the most practical and he wrote <a href="https://github.com/pkg/errors">a package</a> containing a lot of that advice, I found it invaluable as it provided those stack traces I missed.</p>
<h2>Summary</h2>
<p>A lot of people really love Go and are very productive with it, I just was never one of those people and that’s ok. However, I think the advice in this post is reasonably sound and uncontroversial. So, if you find yourself needing to write some code in Go, give this guide a quick perusal. Hope it helps.</p>